import { useEffect, useRef, useState, useCallback } from "react";
import { invoke } from "@tauri-apps/api/core";
import { readText } from "@tauri-apps/plugin-clipboard-manager";
import "./App.css";

// Import components and utilities
import {
  Header,
  ClipboardHistory,
  Footer,
  NotificationBanner,
  TextProcessingResults,
  StatusSection
} from './components';
import { cleanupText } from './utils';
import { appStyles, buttons } from './styles/AppStyles';
import { useNotification, useJwtToken, useClipboardHistory, useTextProcessing } from './hooks';

function App() {
  const [shortcutStatus, setShortcutStatus] = useState<string>("Global shortcut Cmd+Shift+C ready to capture text");
  const lastValueRef = useRef<string>("");

  // Use custom hooks for state management
  const { notification, showNotification, clearNotification } = useNotification();
  const { jwtToken, showTokenInput, setShowTokenInput, saveJwtToken, clearJwtToken, hasJwtToken } = useJwtToken();
  const {
    clipboardHistory,
    searchQuery,
    setSearchQuery,
    filteredHistory,
    selectedEntry,
    setSelectedEntry,
    showHistory,
    setShowHistory,
    loadClipboardHistory,
    searchClipboardHistory,
    deleteHistoryEntry,
    clearAllHistory,
    pasteFromHistory
  } = useClipboardHistory();
  const {
    cleanedText,
    rephrasedText,
    isProcessing,
    isRephrasing,
    setCleanedText,
    processClipboardText,
    copyRephrasedText
  } = useTextProcessing(showNotification, hasJwtToken, setShowTokenInput, loadClipboardHistory);

  // Additional functions not covered by hooks

  // Check accessibility permissions
  async function checkPermissions() {
    try {
      const result = await invoke('check_accessibility_permissions');
      console.log('Accessibility permissions:', result);
    } catch (error) {
  // Handle refresh clipboard button
  const handleRefreshClipboard = useCallback(async () => {
    await processClipboardText();
  }, [processClipboardText]);

  // Test notification function
  const testNotification = useCallback(async () => {
    await showNotification('Test notification sent successfully!', 'success');
  }, [showNotification]);

  // Handle logout (clear JWT token)
  const handleLogout = useCallback(() => {
    clearJwtToken();
  }, [clearJwtToken]);

  // Setup permissions and clipboard monitoring
  useEffect(() => {
    let mounted = true;

    // Load clipboard history on mount
    loadClipboardHistory();

    // Monitor clipboard for changes
    const readOnce = async () => {
      try {
        const text = (await readText()) ?? "";
        if (mounted && text !== lastValueRef.current) {
          lastValueRef.current = text;
          const cleaned = cleanupText(text);

          if (cleaned && cleaned !== "") {
            setCleanedText(cleaned);

            // Automatically copy cleaned text back to clipboard
            try {
              await invoke('add_to_clipboard_history', {
                content: cleaned,
                is_cleaned: true,
                original_content: text
              });
              // Reload clipboard history to show new entries
              await loadClipboardHistory();
            } catch (error) {
              console.error('Failed to add to clipboard history:', error);
            }

            setShortcutStatus(`‚úÖ Text cleaned and copied! ${new Date().toLocaleTimeString()}`);

            // Trigger auto-rephrase after cleanup
            // Note: autoRephrase functionality is now handled by useTextProcessing hook

            setTimeout(() => {
              setShortcutStatus("Global shortcut Cmd+Shift+C ready to capture text");
            }, 3000);
          } else {
            setShortcutStatus(`‚ö†Ô∏è No text to clean`);
            setTimeout(() => {
              setShortcutStatus("Global shortcut Cmd+Shift+C ready to capture text");
            }, 3000);
          }
        }
      } catch (error) {
        console.error('Failed to read clipboard:', error);
        setShortcutStatus(`‚ùå Error reading clipboard: ${error}`);
        setTimeout(() => {
          setShortcutStatus("Global shortcut Cmd+Shift+C ready to capture text");
        }, 3000);
      }
    };

    // Setup global shortcut listener
    const setupShortcutListener = async () => {
      try {
        await invoke('setup_global_shortcut');
        console.log('Global shortcut setup completed');

        // Start monitoring clipboard
        const startMonitoring = async () => {
          while (mounted) {
            await readOnce();
            await new Promise(resolve => setTimeout(resolve, 1000)); // Check every second
          }
        };

        startMonitoring();
      } catch (error) {
        console.error('Failed to setup global shortcut:', error);
        setShortcutStatus(`‚ùå Failed to setup shortcut: ${error}`);
      }
    };

    setupShortcutListener();

    return () => {
      mounted = false;
    };
  }, [loadClipboardHistory, setCleanedText]);

  // Search effect
  useEffect(() => {
    searchClipboardHistory(searchQuery);
  }, [searchQuery, searchClipboardHistory]);

  // Mock user data - in a real app, this would come from authentication context
  const mockUserData = {
    username: "John Doe",
    userPlan: "Pro",
    usageStats: {
      totalItems: clipboardHistory.length,
      clipboardItems: clipboardHistory.length,
      storageUsed: `${Math.round(clipboardHistory.reduce((acc, item) => acc + item.char_count, 0) / 1024)}KB`,
      dailyLimit: 500,
      dailyUsage: Math.min(clipboardHistory.length * 5, 500)
    }
  };

  return (
    <main className="container" style={appStyles.mainContainer}>
      {/* Professional Header with User Info */}
      <Header 
        username={mockUserData.username}
        userPlan={mockUserData.userPlan}
        usageStats={mockUserData.usageStats}
        onLogout={handleLogout}
      />

      {/* Notification Display */}
      <NotificationBanner
        notification={notification}
        onDismiss={clearNotification}
      />

      {/* JWT Token Configuration */}
      <div style={appStyles.card}>
        <div style={{
          ...appStyles.rowBetween,
          marginBottom: showTokenInput ? '16px' : '0'
        }}>
          <div style={appStyles.rowCenter}>
            <div style={appStyles.iconBox}>
              <span style={appStyles.iconSmall}>üîë</span>
            </div>
            <div>
              <h4 style={appStyles.h4Title}>Authentication</h4>
              <p style={appStyles.mutedText}>
                {jwtToken ? 'JWT token configured' : 'JWT token required for rephrasing'}
              </p>
            </div>
          </div>
          
          <div style={appStyles.rowGap8}>
            <button
              onClick={() => setShowTokenInput(!showTokenInput)}
              style={buttons.primary()}
            >
              {showTokenInput ? 'Cancel' : (jwtToken ? 'Update' : 'Configure')}
            </button>
            
            {jwtToken && (
              <button
                onClick={clearJwtToken}
                style={buttons.danger()}
              >
                Clear
              </button>
            )}
          </div>
        </div>
        
        {showTokenInput && (
          <div style={{ marginTop: '16px' }}>
            <input
              type="password"
              placeholder="Enter your JWT token"
              style={appStyles.input}
              onKeyPress={(e) => {
                if (e.key === 'Enter') {
                  const token = (e.target as HTMLInputElement).value;
                  if (token.trim()) {
                    saveJwtToken(token.trim());
                    (e.target as HTMLInputElement).value = '';
                  }
                }
              }}
            />
            <button
              onClick={(e) => {
                const input = e.currentTarget.previousElementSibling as HTMLInputElement;
                const token = input.value;
                if (token.trim()) {
                  saveJwtToken(token.trim());
                  input.value = '';
                }
              }}
              style={buttons.primary()}
            >
              Save Token
            </button>
          </div>
        )}
      </div>

      {/* Quick Actions Panel */}
      <div style={appStyles.card}>
        <div style={{
          ...appStyles.rowBetween,
          marginBottom: '16px'
        }}>
          <div style={appStyles.rowCenter}>
            <div style={appStyles.iconBox}>
              <span style={appStyles.iconLarge}>‚ö°</span>
            </div>
            <div>
              <h3 style={appStyles.h3Title}>Quick Actions</h3>
              <p style={appStyles.mutedText}>Instant text processing and clipboard management</p>
            </div>
          </div>
          
          <div style={appStyles.rowGap12}>
            <button
              onClick={processClipboardText}
              disabled={isProcessing || isRephrasing}
              style={buttons.primary({ large: true, disabled: isProcessing || isRephrasing })}
              onMouseEnter={(e) => {
                if (!isProcessing && !isRephrasing) {
                  e.currentTarget.style.transform = 'translateY(-2px)';
                  e.currentTarget.style.boxShadow = '0 5px 15px rgba(61, 113, 236, 0.4)';
                }
              }}
              onMouseLeave={(e) => {
                if (!isProcessing && !isRephrasing) {
                  e.currentTarget.style.transform = 'translateY(0)';
                  e.currentTarget.style.boxShadow = '0 3px 10px rgba(61, 113, 236, 0.3)';
                }
              }}
            >
              {(isProcessing || isRephrasing) ? (
                <>
                  <span style={{ animation: 'spin 1s linear infinite' }}>‚è≥</span>
                  {isProcessing ? 'Processing...' : 'Rephrasing...'}
                </>
              ) : (
                <>
                  <span>üßπ</span>
                  Clean Clipboard
                </>
              )}
            </button>
          </div>
        </div>
      </div>

      {/* Status Section */}
      <StatusSection
        shortcutStatus={shortcutStatus}
        isProcessing={isProcessing}
        onRefreshClipboard={handleRefreshClipboard}
        onTestNotification={testNotification}
      />

      {/* Text Processing Results */}
      <TextProcessingResults
        cleanedText={cleanedText}
        rephrasedText={rephrasedText}
        showNotification={showNotification}
      />

      {/* Enhanced Clipboard History Section */}
      <ClipboardHistory
        clipboardHistory={clipboardHistory}
        searchQuery={searchQuery}
        filteredHistory={filteredHistory}
        selectedEntry={selectedEntry}
        showHistory={showHistory}
        onSearchQueryChange={setSearchQuery}
        onSelectEntry={setSelectedEntry}
        onToggleHistory={() => setShowHistory(!showHistory)}
        onDeleteEntry={deleteHistoryEntry}
        onClearAllHistory={clearAllHistory}
        onRefreshHistory={loadClipboardHistory}
        onPasteFromHistory={pasteFromHistory}
      />
      
      {/* Footer */}
      <Footer />
    </main>
  );
}

export default App;
